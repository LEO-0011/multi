"""
YAGAMI UNIVERZE - Bot Handlers
bot/handlers/start_handler.py
"""

import logging
from pyrogram import Client
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton

logger = logging.getLogger(__name__)


async def handle_start(client: Client, message: Message):
    """Handle /start command"""
    
    welcome_text = """
üî• **YAGAMI UNIVERZE** - Universal Bot Generator

I can create ANY Telegram bot for you automatically!

**What I can do:**
‚úÖ Generate complete bot code from your description
‚úÖ Create Dockerfile and docker-compose setup
‚úÖ Scan GitHub repos and extract env variables
‚úÖ Deploy bots automatically
‚úÖ Support multiple languages (Python, Node.js, Go, PHP)

**How to use:**
1Ô∏è‚É£ Describe the bot you want
2Ô∏è‚É£ I'll generate all the code
3Ô∏è‚É£ Deploy with one command

**Examples:**
‚Ä¢ `/generate Create an RSS feed bot that posts to channel`
‚Ä¢ `/generate Build a file converter bot for documents`
‚Ä¢ `/scan https://github.com/username/bot-repo`

Just describe what you want, and I'll build it! üöÄ
    """
    
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("üìö Examples", callback_data="examples")],
        [InlineKeyboardButton("‚ùì Help", callback_data="help")],
        [InlineKeyboardButton("üîß My Bots", callback_data="my_bots")]
    ])
    
    await message.reply_text(welcome_text, reply_markup=keyboard)


"""
bot/handlers/generate_handler.py
"""

import logging
import asyncio
from datetime import datetime
from pathlib import Path
from pyrogram import Client
from pyrogram.types import Message
from generator_engine.ai_generator import AIGenerator
from generator_engine.code_writer import CodeWriter
from bot.config import Config

logger = logging.getLogger(__name__)


async def handle_generate(client: Client, message: Message, direct_prompt: bool = False):
    """Handle bot generation request"""
    
    user_id = message.from_user.id
    
    # Extract prompt
    if direct_prompt:
        prompt = message.text
    else:
        command_parts = message.text.split(maxsplit=1)
        if len(command_parts) < 2:
            await message.reply_text(
                "‚ùå Please provide a bot description.\n\n"
                "**Example:**\n"
                "`/generate Create an auto-reply bot that responds to keywords`"
            )
            return
        prompt = command_parts[1]
    
    # Send processing message
    status_msg = await message.reply_text(
        "üî• **YAGAMI UNIVERZE is working...**\n\n"
        "‚è≥ Analyzing your request..."
    )
    
    try:
        # Initialize generator
        generator = AIGenerator()
        
        # Update status
        await status_msg.edit_text(
            "üî• **YAGAMI UNIVERZE is working...**\n\n"
            "üß† Generating bot architecture...\n"
            "‚è≥ This may take 30-60 seconds..."
        )
        
        # Generate bot
        bot_data = await generator.generate_bot(prompt, user_id)
        
        # Update status
        await status_msg.edit_text(
            "üî• **YAGAMI UNIVERZE is working...**\n\n"
            "üìù Writing files...\n"
            "‚è≥ Almost done..."
        )
        
        # Create bot directory
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        bot_name = bot_data['name']
        bot_id = f"{bot_name}_{timestamp}"
        bot_dir = Config.GENERATED_BOTS_DIR / bot_id
        
        # Write files
        writer = CodeWriter()
        await writer.write_bot(bot_dir, bot_data)
        
        # Create archive
        archive_path = await writer.create_archive(bot_dir)
        
        # Success message
        success_text = f"""
‚úÖ **Bot Generated Successfully!**

üì¶ **Bot Name:** `{bot_name}`
üÜî **Bot ID:** `{bot_id}`
üíª **Language:** {bot_data['language']}
üîß **Framework:** {bot_data['framework']}

üìÅ **Generated Files:**
{chr(10).join(f'  ‚Ä¢ {f}' for f in list(bot_data['files'].keys())[:10])}
{f'  ... and {len(bot_data["files"]) - 10} more' if len(bot_data['files']) > 10 else ''}

üîê **Required Environment Variables:**
```
{chr(10).join(bot_data['env_vars'])}
```

üì• **Download your bot below!**

**Next Steps:**
1Ô∏è‚É£ Download the bot archive
2Ô∏è‚É£ Extract and fill in .env file
3Ô∏è‚É£ Run: `docker-compose up -d`

Or use: `/deploy {bot_id}` for auto-deployment
        """
        
        # Send archive
        await message.reply_document(
            document=str(archive_path),
            caption=success_text,
            file_name=f"{bot_id}.zip"
        )
        
        # Delete status message
        await status_msg.delete()
        
        logger.info(f"Successfully generated bot {bot_id} for user {user_id}")
        
    except Exception as e:
        logger.error(f"Error generating bot: {e}")
        await status_msg.edit_text(
            f"‚ùå **Error generating bot**\n\n"
            f"Error: {str(e)}\n\n"
            f"Please try again or contact admin."
        )


"""
bot/handlers/repo_scan_handler.py
"""

import logging
from pyrogram import Client
from pyrogram.types import Message
from generator_engine.repo_scanner import RepoScanner

logger = logging.getLogger(__name__)


async def handle_repo_scan(client: Client, message: Message):
    """Handle GitHub repository scanning"""
    
    command_parts = message.text.split(maxsplit=1)
    
    if len(command_parts) < 2:
        await message.reply_text(
            "‚ùå Please provide a GitHub repository URL.\n\n"
            "**Example:**\n"
            "`/scan https://github.com/username/telegram-bot`"
        )
        return
    
    repo_url = command_parts[1].strip()
    
    # Validate URL
    if not repo_url.startswith('https://github.com/'):
        await message.reply_text(
            "‚ùå Invalid GitHub URL.\n\n"
            "Please provide a valid GitHub repository URL starting with:\n"
            "`https://github.com/`"
        )
        return
    
    status_msg = await message.reply_text(
        "üîç **Scanning repository...**\n\n"
        "‚è≥ Cloning and analyzing code..."
    )
    
    try:
        scanner = RepoScanner()
        scan_results = await scanner.scan_repository(repo_url)
        
        # Generate env template
        env_template = scanner.generate_env_template(
            scan_results['env_vars'],
            scan_results['readme_content']
        )
        
        # Create results message
        results_text = f"""
‚úÖ **Repository Scan Complete!**

üì¶ **Repository:** {repo_url}
üíª **Language:** {scan_results['language']}
üîß **Framework:** {scan_results['framework']}

üìÅ **Structure:**
  Files: {len(scan_results['structure']['files'])}
  Directories: {len(scan_results['structure']['directories'])}

üì¶ **Dependencies:** {len(scan_results['dependencies'])}
{chr(10).join(f'  ‚Ä¢ {dep}' for dep in scan_results['dependencies'][:5])}
{f'  ... and {len(scan_results["dependencies"]) - 5} more' if len(scan_results['dependencies']) > 5 else ''}

üîê **Environment Variables Found:** {len(scan_results['env_vars'])}
```
{chr(10).join(scan_results['env_vars'])}
```

üîß **Configuration:**
{chr(10).join(f'  ‚Ä¢ {k.replace("_", " ").title()}: {"‚úÖ" if v else "‚ùå"}' for k, v in scan_results['config_patterns'].items())}

üìÑ **Generated .env template below ‚¨áÔ∏è**
        """
        
        # Send results
        await status_msg.edit_text(results_text)
        
        # Send env template as file
        env_file_path = Config.TEMP_DIR / f"env_template_{message.from_user.id}.txt"
        env_file_path.write_text(env_template)
        
        await message.reply_document(
            document=str(env_file_path),
            caption="üìÑ **.env Template**\n\nFill in your values and rename to `.env`",
            file_name=".env.example"
        )
        
        env_file_path.unlink()
        
    except Exception as e:
        logger.error(f"Error scanning repository: {e}")
        await status_msg.edit_text(
            f"‚ùå **Error scanning repository**\n\n"
            f"Error: {str(e)}\n\n"
            f"Make sure the repository is public or you've set GITHUB_TOKEN."
        )


"""
bot/handlers/deploy_handler.py
"""

import logging
import asyncio
import subprocess
from pathlib import Path
from pyrogram import Client
from pyrogram.types import Message
from bot.config import Config

logger = logging.getLogger(__name__)


async def handle_deploy(client: Client, message: Message):
    """Handle bot deployment"""
    
    command_parts = message.text.split(maxsplit=1)
    
    if len(command_parts) < 2:
        await message.reply_text(
            "‚ùå Please provide a bot ID.\n\n"
            "**Example:**\n"
            "`/deploy bot_20231121_123456`\n\n"
            "You can find bot IDs in your generated bot messages."
        )
        return
    
    bot_id = command_parts[1].strip()
    bot_dir = Config.GENERATED_BOTS_DIR / bot_id
    
    if not bot_dir.exists():
        await message.reply_text(
            f"‚ùå **Bot not found**\n\n"
            f"Bot ID: `{bot_id}`\n\n"
            f"Make sure you've generated this bot first using `/generate`"
        )
        return
    
    status_msg = await message.reply_text(
        "üöÄ **Deploying bot...**\n\n"
        "‚è≥ Checking environment..."
    )
    
    try:
        # Check if .env exists
        env_file = bot_dir / ".env"
        if not env_file.exists():
            await status_msg.edit_text(
                "‚ùå **Missing .env file**\n\n"
                "Please create a .env file with your configuration first.\n\n"
                "You can find the .env.example in your bot archive."
            )
            return
        
        # Update status
        await status_msg.edit_text(
            "üöÄ **Deploying bot...**\n\n"
            "üê≥ Building Docker image..."
        )
        
        # Build Docker image
        build_process = await asyncio.create_subprocess_exec(
            'docker-compose', 'build',
            cwd=str(bot_dir),
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )
        
        stdout, stderr = await build_process.communicate()
        
        if build_process.returncode != 0:
            error_msg = stderr.decode() if stderr else "Unknown error"
            await status_msg.edit_text(
                f"‚ùå **Build failed**\n\n"
                f"```\n{error_msg[:500]}\n```"
            )
            return
        
        # Update status
        await status_msg.edit_text(
            "üöÄ **Deploying bot...**\n\n"
            "üê≥ Starting containers..."
        )
        
        # Start containers
        start_process = await asyncio.create_subprocess_exec(
            'docker-compose', 'up', '-d',
            cwd=str(bot_dir),
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )
        
        stdout, stderr = await start_process.communicate()
        
        if start_process.returncode != 0:
            error_msg = stderr.decode() if stderr else "Unknown error"
            await status_msg.edit_text(
                f"‚ùå **Deployment failed**\n\n"
                f"```\n{error_msg[:500]}\n```"
            )
            return
        
        # Success
        await status_msg.edit_text(
            f"‚úÖ **Bot deployed successfully!**\n\n"
            f"üÜî **Bot ID:** `{bot_id}`\n"
            f"üê≥ **Status:** Running\n\n"
            f"**Useful commands:**\n"
            f"‚Ä¢ View logs: `docker-compose logs -f`\n"
            f"‚Ä¢ Stop bot: `docker-compose down`\n"
            f"‚Ä¢ Restart: `docker-compose restart`\n\n"
            f"üìÅ Bot directory: `{bot_dir}`"
        )
        
        logger.info(f"Successfully deployed bot {bot_id}")
        
    except Exception as e:
        logger.error(f"Error deploying bot: {e}")
        await status_msg.edit_text(
            f"‚ùå **Deployment error**\n\n"
            f"Error: {str(e)}\n\n"
            f"Make sure Docker is installed and running."
        )
